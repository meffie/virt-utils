#!/bin/bash
#
# Spin-up a temporary vm from an existing domain (which is shutdown), run a
# series of commands, then delete the temporary vm.  Useful for doing builds
# and tests.
#
# Before running, create a domain to be used as the base image. Create a
# regular user account to be used to run commands and install a public key in
# the user's authorized_keys.  The virt-builder tool can be used to
# automate the construction of the base image.
#
#---------------------------------------------------------------------------


export LIBVIRT_DEFAULT_URI="${LIBVIRT_DEFUALT_URI:-qemu:///system}"

vmbase=""
vmbaseprefix=""
vmcloneprefix=""
vmname=""
vmaddr=""
vmstate=""
vmdomstate=""
vmcwd=""

opt_nodelete=no
opt_wait=10

ssh_exit_code=1
ssh_user="$USER"
ssh_opts=""\
" -t -t"\
" -o BatchMode=yes"\
" -o UserKnownHostsFile=/dev/null"\
" -o StrictHostKeyChecking=no"\
" -o LogLevel=ERROR"

usage() {
    cat <<_EOF_
usage: virt-run --base=<domain>
                [--base-prefix <prefix>]
                [--clone-prefix <prefix>]
                [--user=<user>]
                [--connect=<uri>]
                [--nodelete]
                "<command>" ["<command>" ...]
_EOF_
}

info() {
    echo "INFO: $1" #>&2
}

warn() {
    echo "WARNING: $1" >&2
}

die() {
    echo "ERROR: $1" >&2
    exit 1
}

#
# Send a command to the guest via ssh.
#
send_cmd() {
    local cmd="$1"
    local opts="$ssh_opts"
    if [ ! -z "$ssh_user" ]; then
        opts="$opts -l $ssh_user"
    fi
    if [ -z "$cmd" ]; then
        warn "Command is missing."
        return
    fi
    if [ -z "$vmaddr" ]; then
        die "IP address for '$vmname' is not set."
    fi
    if [ ! -z "$vmcwd" ]; then
        cmd="cd $vmcwd && $cmd"
    fi
    ssh $opts $vmaddr $cmd
    ssh_exit_code=$?
}

wait_until_booted() {
    sleep $opt_wait
    for i in {1..20}; do
        vmdomstate=`virsh domstate $vmname`
        if [ "$vmdomstate" = "running" ]; then
            break
        fi
        sleep $opt_wait
    done
    if [ "$vmdomstate" != "running" ]; then
        die "Domain '$vmname' failed to start."
    fi
    for i in {1..20}; do
        vmaddr=`virt-ip -m agent $vmname`
        if [ ! -z $vmaddr ]; then
            break
        fi
        sleep $opt_wait
    done
    if [ -z $vmaddr ]; then
        die "Failed to find ip address of vm '$vmname'."
    fi
    info "Attempting to connect to '$vmaddr'."
    for i in {1..20}; do
        send_cmd "systemctl is-system-running | grep '^running$'"
        if [ $ssh_exit_code -eq 0 ]; then
            vmstate="running"
            break
        fi
        sleep $opt_wait
    done
    if [ "$vmstate" != "running" ]; then
        die "Failed to reach running state in vm '$vmname'."
    fi
    info "Guest '$vmname' is running."
}

reap_orphans() {
    local vm=
    local pid=
    for vm in `virsh list --name`; do
        if ! echo $vm | grep -q -P "^${vmcloneprefix}${vmbase}-\d+$"; then
            continue
        fi
        pid=`echo $vm | sed "s/^${vmcloneprefix}${vmbase}-//"`
        if [ -d /proc/$pid ]; then
            continue
        fi
        if cat /proc/$pid/cmdline | grep -q -P "\bvirt-run\b"; then
            continue
        fi
        info "Deleting orphan domains '$vm'."
        virt-destroy $vm
    done
}

args=`getopt --option b:c:u: --long base:,base-prefix:,clone-prefix:,connect:,user:,nodelete,wait: --name 'virt-run' -- "$@"`
if [ $? != 0 ]; then
    usage
    exit 1
fi
eval set -- "$args"
while :; do
    case "$1" in
        -b|--base) vmbase="$2" ; shift 2 ;;
        --base-prefix) vmbaseprefix="$2" ; shift 2 ;;
        --clone-prefix) vmcloneprefix="$2" ; shift 2 ;;
        -c|--connect) export LIBVIRT_DEFAULT_URI="$2" ; shift 2 ;;
        --nodelete) opt_nodelete=yes ; shift ;;
        -u|--user) ssh_user="$2" ; shift 2 ;;
        --wait) opt_wait="$2"; shift 2 ;;
        --) shift ; break ;;
        *) die "Internal error handling options." ;;
    esac
done
if [ $# -eq 0 ]; then
    usage
    exit 1
fi
if [ -z "$vmbase" ]; then
    usage
    exit 1
fi

info "Checking for orphan domains."
reap_orphans

vmname="${vmcloneprefix}${vmbase}-$$"
info "Cloning '${vmbaseprefix}${vmbase}' to '$vmname'."
(
    flock -x -w 60 200
    virt-clone --auto-clone --original ${vmbaseprefix}${vmbase} --name ${vmname}
) 200>$HOME/.virt-clone.lock
if [ $? -ne 0 ]; then
    die "Failed to clone '${vmbaseprefix}${vmbase}' to '${vmname}'."
fi

virsh start ${vmname} ||
    die "Failed to start '${vmname}'."

info "Waiting for the guest vm '${vmname}' to boot."
wait_until_booted

info "Running commands."
exit_code=0
for cmd in "$@"; do
    info "--> '$cmd'"
    case "$cmd" in
    @onfail*)
        # Skip post processing commands.
        ;;
    @cd*)
        # Change directory to use for subsequent commands.
        vmcwd=`echo "$cmd" | sed 's/@cd //'`
        info "Setting working directory to $vmcwd"
        ;;
    @reboot)
        # Reboot the guest.
        virsh reboot ${vmname}
        wait_until_booted
        ;;
    @say*)
        info "`echo "$cmd" | sed 's/@say //'`"
        ;;
    @skip*)
        ;;
    @sleep*)
        # Delay for a bit before running the next command.
        delay=`echo "$cmd" | sed 's/@sleep //'`
        info "Sleeping for $delay seconds"
        sleep "$delay"
        ;;
    @*)
        warn "Unknown command: $cmd"
        ;;
    *)
        send_cmd "$cmd"
        exit_code=$ssh_exit_code # set by send_cmd
        if [ $exit_code -ne 0 ] ; then
            warn "Command failed with code $exit_code: '$cmd'."
            break
        fi
        ;;
    esac
done

# Run post processing commands before deleting the guest.
if [ $exit_code -ne 0 ] ; then
    for cmd in "$@"; do
        case "$cmd" in
        @onfail*)
            cmd=`echo "$cmd" | sed "s/@onfail //"`
            send_cmd "$cmd"
            ;;
        *)
            ;;
        esac
    done
fi

if [ "$opt_nodelete" = "yes" ]; then
    warn "Skipping delete of '$vmname'."
else
    info "Deleting domain '$vmname'."
    virt-destroy $vmname
fi
exit $exit_code # propagate the command error
