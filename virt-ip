#!/usr/bin/env python

import sys
import argparse
import time
from subprocess import check_output
import xml.etree.ElementTree as ET
#from pprint import pprint as pp

PY2 = (sys.version_info[0] == 2)
PY3 = (sys.version_info[0] == 3)

class VirtIpError(Exception):
    pass

def get_macs(domain):
    try:
        xml = check_output(['virsh', 'dumpxml', domain])
    except:
        raise VirtIpError("Unable to dumpxml for domain '%s'" % domain)
    if PY3:
        xml = str(xml, 'utf-8')
    root = ET.fromstring(xml)
    macs = []
    for e in root.findall('devices/interface/mac[@address]'):
        macs.append(e.attrib['address'])
    if len(macs) == 0:
        raise VirtIpError("No mac addresses found for domain '%s'" % domain)
    #pp(('macs', macs))
    return macs

def get_ip_from_agent(domain):
    addresses = []
    macs = get_macs(domain)
    output = check_output(['virsh', 'domifaddr', '--full',
                           '--source', 'agent', domain])
    if PY3:
        output = str(output, 'utf-8')
    for mac in macs:
        for line in output.splitlines():
            f = line.split()
            if len(f) != 4:
                continue
            if f[0] != 'lo' and f[1] == mac and f[2] == 'ipv4':
                address = f[3].split('/')[0]
                addresses.append(address)
    return addresses

def get_networks():
    networks = []
    output = check_output(['virsh', 'net-list', '--name'])
    if PY3:
        output = str(output, 'utf-8')
    for line in output.splitlines():
        line = line.strip()
        if line:
            networks.append(line)
    return networks

def get_ip_from_dhcp_leases(domain):
    addresses = []
    networks = get_networks()
    macs = get_macs(domain)
    for mac in macs:
       for network in networks:
            output = check_output(['virsh', 'net-dhcp-leases',
                                  network, '--mac', mac])
            if PY3:
               output = str(output, 'utf-8')
            for line in output.splitlines():
                f = line.split()
                if len(f) != 7:
                    continue
                if f[3] == 'ipv4':
                    address = f[4].split('/')[0]
                    addresses.append(address)
    return addresses

def get_ip_from_arp_cache(domain):
    addresses = []
    macs = get_macs(domain)
    output = check_output(['arp', '-n', '-e'])
    if PY3:
        output = str(output, 'utf-8')
    for mac in macs:
        for line in output.splitlines():
            f = line.split()
            if len(f) != 5:
                continue
            if f[2] == mac:
                addresses.append(f[0])
    return addresses

def parse_args():
    p = argparse.ArgumentParser()
    p.add_argument('--method', choices=('agent','dhcp','arp'), default='agent',
                   help='Lookup method (default: agent)')
    p.add_argument('--retries', default=0, type=int,
                   help='Number of retries (default: 0)')
    p.add_argument('--delay', default='10', type=int,
                   help='How many seconds to wait between retries (default: 10)')
    p.add_argument('domain')
    return p.parse_args()

def main():
    method = {
        'agent': get_ip_from_agent,
        'dhcp': get_ip_from_dhcp_leases,
        'arp': get_ip_from_arp_cache,
    }
    args = parse_args()
    retries = args.retries
    while True:
        try:
            addrs = method[args.method](args.domain)
            for addr in addrs:
                print(addr)
                return 0
        except Exception as e:
            if retries > 0:
                s = '' if args.delay == 1 else 's'
                sys.stderr.write("Retrying in %d second%s.\n" % (args.delay, s))
                retries -= 1
                time.sleep(args.delay)
            else:
                sys.stderr.write("Unable to get address: %s\n" % e)
                return 1

if __name__ == '__main__':
    sys.exit(main())
